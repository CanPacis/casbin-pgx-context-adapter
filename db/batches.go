// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: batch.go

package db

import (
	"context"
	"errors"

	"github.com/jackc/pgx/v5"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const insertPolicy = `-- name: InsertPolicy :batchexec
INSERT INTO
  access_rules (id, ptype, v0, v1, v2, v3, v4, v5)
VALUES
  (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
  )
ON conflict (id) do nothing
`

type InsertPolicyBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

func (q *Queries) InsertPolicy(ctx context.Context, arg []AccessRule) *InsertPolicyBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ID,
			a.Ptype,
			a.V0,
			a.V1,
			a.V2,
			a.V3,
			a.V4,
			a.V5,
		}
		batch.Queue(insertPolicy, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &InsertPolicyBatchResults{br, len(arg), false}
}

func (b *InsertPolicyBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *InsertPolicyBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const removePolicy = `-- name: RemovePolicy :batchexec
DELETE FROM access_rules
WHERE
  id = $1
`

type RemovePolicyBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

func (q *Queries) RemovePolicy(ctx context.Context, id []string) *RemovePolicyBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(removePolicy, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &RemovePolicyBatchResults{br, len(id), false}
}

func (b *RemovePolicyBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *RemovePolicyBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const softRemovePolicy = `-- name: SoftRemovePolicy :batchexec
UPDATE access_rules
SET
  deleted_at = NOW()
WHERE
  id = $1
`

type SoftRemovePolicyBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

func (q *Queries) SoftRemovePolicy(ctx context.Context, id []string) *SoftRemovePolicyBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(softRemovePolicy, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &SoftRemovePolicyBatchResults{br, len(id), false}
}

func (b *SoftRemovePolicyBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *SoftRemovePolicyBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const updateFilteredPolicy = `-- name: UpdateFilteredPolicy :batchexec
UPDATE access_rules
SET
  ptype = coalesce($1, ptype),
  v0 = coalesce($2, v0),
  v1 = coalesce($3, v1),
  v2 = coalesce($4, v2),
  v3 = coalesce($5, v3),
  v4 = coalesce($6, v4),
  v5 = coalesce($7, v5)
WHERE
  ptype = $8
  AND (
    v0 LIKE coalesce($9, '%')
    OR v0 IS NULL
  )
  AND (
    v1 LIKE coalesce($10, '%')
    OR v1 IS NULL
  )
  AND (
    v2 LIKE coalesce($11, '%')
    OR v2 IS NULL
  )
  AND (
    v3 LIKE coalesce($12, '%')
    OR v3 IS NULL
  )
  AND (
    v4 LIKE coalesce($13, '%')
    OR v4 IS NULL
  )
  AND (
    v5 LIKE coalesce($14, '%')
    OR v5 IS NULL
  )
  AND deleted_at IS NULL
`

type UpdateFilteredPolicyBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

func (q *Queries) UpdateFilteredPolicy(ctx context.Context, filter AccessRule, arg []AccessRule) *UpdateFilteredPolicyBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Ptype,
			a.V0,
			a.V1,
			a.V2,
			a.V3,
			a.V4,
			a.V5,
			filter.Ptype,
			filter.V0,
			filter.V1,
			filter.V2,
			filter.V3,
			filter.V4,
			filter.V5,
		}
		batch.Queue(updateFilteredPolicy, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &UpdateFilteredPolicyBatchResults{br, len(arg), false}
}

func (b *UpdateFilteredPolicyBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *UpdateFilteredPolicyBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const updatePolicy = `-- name: UpdatePolicy :batchexec
UPDATE access_rules
SET
  ptype = coalesce($2, ptype),
  v0 = coalesce($3, v0),
  v1 = coalesce($4, v1),
  v2 = coalesce($5, v2),
  v3 = coalesce($6, v3),
  v4 = coalesce($7, v4),
  v5 = coalesce($8, v5)
WHERE
  id = $1
  and deleted_at IS NULL
`

type UpdatePolicyBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

func (q *Queries) UpdatePolicy(ctx context.Context, arg []AccessRule) *UpdatePolicyBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ID,
			a.Ptype,
			a.V0,
			a.V1,
			a.V2,
			a.V3,
			a.V4,
			a.V5,
		}
		batch.Queue(updatePolicy, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &UpdatePolicyBatchResults{br, len(arg), false}
}

func (b *UpdatePolicyBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *UpdatePolicyBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}
