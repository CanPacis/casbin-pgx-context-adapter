// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package db

import (
	"context"

)

const filteredSoftRemovePolicy = `-- name: FilteredSoftRemovePolicy :exec
UPDATE access_rules
SET
  deleted_at = NOW()
WHERE
  ptype = $1
  AND (
    v0 LIKE coalesce($2, '%')
    OR v0 IS NULL
  )
  AND (
    v1 LIKE coalesce($3, '%')
    OR v1 IS NULL
  )
  AND (
    v2 LIKE coalesce($4, '%')
    OR v2 IS NULL
  )
  AND (
    v3 LIKE coalesce($5, '%')
    OR v3 IS NULL
  )
  AND (
    v4 LIKE coalesce($6, '%')
    OR v4 IS NULL
  )
  AND (
    v5 LIKE coalesce($7, '%')
    OR v5 IS NULL
  )
  AND deleted_at IS NULL
`

func (q *Queries) FilteredSoftRemovePolicy(ctx context.Context, arg AccessRule) error {
	_, err := q.db.Exec(ctx, filteredSoftRemovePolicy,
		arg.Ptype,
		arg.V0,
		arg.V1,
		arg.V2,
		arg.V3,
		arg.V4,
		arg.V5,
	)
	return err
}

const loadPolicy = `-- name: LoadPolicy :many
SELECT
  id, ptype, v0, v1, v2, v3, v4, v5, deleted_at
FROM
  access_rules
WHERE
  deleted_at IS NULL
`

func (q *Queries) LoadPolicy(ctx context.Context) ([]AccessRule, error) {
	rows, err := q.db.Query(ctx, loadPolicy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AccessRule
	for rows.Next() {
		var i AccessRule
		if err := rows.Scan(
			&i.ID,
			&i.Ptype,
			&i.V0,
			&i.V1,
			&i.V2,
			&i.V3,
			&i.V4,
			&i.V5,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
